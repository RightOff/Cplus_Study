# 笔试

## 深圳震有科技_20240915

1. 字符串中查找子串。[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)
2. 转换六进制数
3. 完美数

## 海康_20240915

1. Linux 下哪些命令可以查看某个连接的TCP状态和收发情况？

   > netstat -antp | grep <目的IP或端口>
   > ss -atn | grep <目的IP或端口>
   > -a: 显示所有链接
   > -n: 以数字形式显示地址和端口
   > -t: 仅显示TCP连接
   > -p: 显示进程信息
   >
2. 模块化程序设计的目标是使程序更加规范、易读、易维护，从而降低程序开发和维护的复杂度。
3. 数组名不能自增。
4. inline 函数概念？

   > inline 只是对编译器的一个建议，不是强制性的命令。
   > inline 函数不能是直接递归函数(自己内部还调用自己的函数)，但编译器可能会忽略对递归函数的inline优化，特别是递归深度较大时。
   > inline 函数的定义可以不在头文件中，但是在每个需要用它的文件里边都需要对其进行定义，甚至是不同的定义。C++类中实现的成员函数会被编译器默认判定为inline函数。
   >
5. 操作系统实现按名存取的关键在于：解决文件名与文件存储地址的转换。
6. 常见通讯总线 SPI、I²C 和 RS-232 的速率关系？

   > SPI > I²C > RS-232
   >
7. 软中断？?软中断的回调函数必须在关闭中断的环境下执行么？？中断处理是由软件完成的么？？
8. Linux下查看内存使用情况的命令？

   > free -h
   > top
   > htop
   > ps
   > cat /proc/meminfo
   > vmstat 1
   > smem
   >
9. 变长数组可以在任何函数中调用么？？
10. CPU架构？

    > ARM CPU 大多数采用的是**修正的哈佛结构** ，而不是单纯的冯诺依曼结构。ARM CPU 核的缓存（cache）通常包括指令缓存（I-Cache, Instruction Cache）和数据缓存（D-Cache, Data Cache） 。
    > Intel x86 CPU 的体系结构是基于冯诺依曼结构的改进和优化版本 。
    >
11. 写一个宏定义求出数组的元素个数

    > #define ARRAY_SIZE(arr) ( sizeof(arr) / sizeof(arr[0]) )
    >
12. 简述网络上的流量控制和拥塞控制

    > **1.流量控制：**
    > 作用：用于防止发送方发送数据过快，超出接收方处理能力的机制，保障了通信的可靠性。
    > 工作原理：接收方通过反馈机制告知发送方自己能接收的数据量，发送方根据反馈，调整自己的发送速度。
    > 常用机制：TCP滑动窗口，发送发根据接收方提供的接收窗口大小来控制发送量，防止接收方缓冲区溢出。
    >
    > **2.拥塞控制**：
    > 作用：防止网络中的数据流量超过网络的承载能力，避免网络拥塞或缓解一发生的拥塞。
    > 工作原理：当网络出现拥塞时，网络中的路由器或交换机会丢弃数据包，发送方根据丢包情况判断网络是否拥塞，并相应减少数据发送速率。
    > 拥塞的标志：重传计时器超时、接收到三个重复确认。
    > 常用算法及流程：
    >
    > + 慢启动，在刚加入网络连接时，一点点提速，扩大发送拥塞窗口，每收到一个ACK，窗口+1，每过一个RTT（往返时延）窗口*2(指数增长)，当到达慢开始门限时，进入拥塞避免算法。
    > + 拥塞避免，窗口大小到达慢开始门限时，将以线性上升，避免增长过快导致网络拥塞。当网络阻塞时，将慢开始门限设置为当前窗口/2或者将当期窗口直接置为1。
    > + 快重传，在收到3个重复确认时判断网络拥塞，立即开始重传并将门限减半，不用等到TRO超时。
    > + 快恢复，由于收到了3个重复确认，说明网络情况变好，可以快速恢复，因此将拥塞窗口直接设置为拥塞门限大小，然后进入拥塞避免算法。
    >

## 华勤_20240915

1. 平衡二叉树深度为4，最少的结点数？

   > 7个
   >
2. const 函数能作为重载判断标志么？

   > 可以，并且const修饰指针(或引用)指向的内容也会改变函数签名，如果const之修饰指针不会。
   >
3. 布尔类型的默认初始化值？

   > 内置类型初始化的取值取决于变量生命的位置以及是否为静态变量。
   > 静态变量和全局变量，无论在何处声明，都默认初始化为0；其他在函数体内声明的其默认初始化的值是未定义的，其值为垃圾数据。
   >

## **tap4fun_20240913**

1. 哈夫曼编码
2. 观察者模式
   > 又称为(发布-订阅模式)，属于行为模式的一种，定义了一种一对多的依赖关系，让多个观察者同时监听一个主题对象，当主题对象发生变化时，所有依赖于它的观察者都得到通知并被自动更新。
   > **优点**：将主题与观察者的关系解耦，两者互不干扰，主题关注自身状态的变化，观察者关注主题状态变化时自己要执行的操作。
   > **应用场景**：适用于一个对象的状态变化会影响到其他对象，并且希望该对象再变化时能自动更新其他对象的状态。比如：GUI中按钮、滑动条组件状态的变化通知其他组件更新；分布式系统中，实现节点之间的消息通知。
   >
3. 闭包形成的必要条件：必须是一个嵌套函数，内嵌函数必须使用外部嵌套函数中的变量，外部函数返回值必须是内嵌函数。C++11中lambda、function、bind。
4. 主动关闭TCP连接的一端在最后会出现TIME-WAIT
5. ping不涉及TCP协议，涉及ICMP协议、ARP协议等等
6. 传输层：包含端口号
7. 网络层：ICMP 用于报告网络设备之间的错误消息和操作信息。包含目的地址IP
8. 数据链路层：ARP将IP地址解析为物理地址（MAC地址）
9. CPU cache line 的大小一般为2的幂
10. UDP发送的数据报和接收的数据包可能大小一致，但不一定所有情况都是，因为IP层可能进行分片（发送数据超过网络的最大传输单元MTU）
11. 判断有向图有环的方法：深度优先遍历和拓扑排序
12. 构造函数不能为虚函数，析构可以，静态函数不可以，私有函数可以
13. 互斥锁可能会导致线程阻塞，自旋锁不会
14. 就算控制好编译器参数，也需要加上memory barrier来控制内存访问顺序。因为会存在编译器重排序、CPU重排序

# 面试

## 古瑞瓦特一面_20241008

1. C++11特性有哪些，智能指针有哪几种？
2. select、poll、epoll 区别和对应场景？
3. 多线程同步的方式？线程之间有数据往来有哪几种方式？
   > 数据往来：共享内存、消息队列、命名管道
   > 同步方式：条件变量、信号量
   >
4. 线程间互斥有哪几种方式？什么时候用锁、什么时候用信号量？
   > 锁、信号量(P、V操作)、条件变量
   > 锁管理单个资源、信号量可以管理单个和多个资源
   >

## 字节跳动客户端一面_20240919

1. 3D 渲染怎么做的？？
2. 3D 骨骼动画实现原理？？
3. 光秃秃的骨骼？？人体身穿的皮肤、铠甲如何获取后显示出来？？
4. 了解过纹理么？
5. 3D图像投影成图片如何做？？
6. 相机中三维坐标如何转换为二维？？
7. 人体姿态彩色图像的格式是什么？YUV颜色空间和RGB的区别了解么？？（HSV也可以了解一下）

   > BGRA
   >
8. openGL有了解么？？
9. openCV如何将彩色图转换灰度图？函数是什么？

   > 三个通道加权平均或简单平均。
   > cvtColor(image_RGB, image_gray, COLOR_BGR2GRAY);
   >
10. 图像做锐化处理如何做？

    > 拉普拉斯算子锐化
    > [【图像增强——7种锐化方法原理与实现(C++、Python、shader GLSL)】_图像锐化算法-CSDN博客](https://blog.csdn.net/sCs12321/article/details/129459772)
    >
11. 如何检测边缘？

    > sobel算子计算梯度
    > [OpenCV||超详细的图像边缘检测_opencv 边缘检测-CSDN博客](https://blog.csdn.net/m0_56230886/article/details/140908030)
    >
12. 图像频域相关的东西？？（傅里叶变换）
13. 线程、进程和协程？（再梳理清楚点，太浅）

    > co_await func();
    >
    > **`co_await`** ：用于挂起协程的执行，等待某个异步操作完成。
    >
    > **`co_return`** ：用于返回协程的结果，并结束协程的执行。
    >
    > **`co_yield`** ：用于生成一个值并挂起协程的执行，允许协程在多个点之间返回值。
    >
14. 线程为什么能加速计算？（当时举了并行计算的例子）
15. 进程间的通信方式？分别有什么应用场景？（信号量、管道场景答得不好）

    > 管道：是一种特殊的文件类型，但没有名字，当两个进程是父子进程，且只进行简单的数据传输时，可以使用管道通信；
    > 命名管道：是一种特殊的文件类型，有名字，当两个进程需要长期通信时，可以使用命名管道；
    > 消息队列：当两个进程之间传递大量数据时，可以使用消息队列；
    > 共享内存：当两个进程需要频繁交换数据时，可以使用共享内存；
    > 信号量：当多个进程需要同时访问某一共享资源时，可以使用信号量进行同步；
    > 套接字：在不同计算机之间进行通信时，可以使用套接字；同一计算机不同进程也可以使用。
    >
16. 共享内存了解？调用什么函数、操作系统状态发生什么变化？为什么要从用户态转换为内核态？共享内存用于什么场景？（说的是 epoll 返回活跃事件的场景）

    > ftok()生成唯一的key，shmget、shmat、shmdt、shmctl。
    >
    > [linux的两种共享内存方式---mmap和shmat区别_mmap和shmat的区别-CSDN博客](https://blog.csdn.net/wangrenhaioylj/article/details/109119466)
    >
    > [进程间通信——共享内存（Shared Memory）_进程间通讯 共享内存-CSDN博客](https://blog.csdn.net/ypt523/article/details/79958188)
    >
17. 物理内存和虚拟内存的区别？页是什么概念？内存不够了会怎么样？

    > [虚拟内存和物理内存的直观理解（概念、区别与联系）_虚拟内存和物理内存的区别-CSDN博客](https://blog.csdn.net/a063225/article/details/103156819)
    >
18. 内存泄漏是怎么出现的？（项目中内存泄漏在任务管理器中的表现）

    > **内存泄露 memory leak** ，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！
    > 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
    >
19. 简历中 VLD 和 Valgrind 有区别么？

    > VLD为Visual C++用户设计的。简单易用，只需要在需要进行内存泄漏检测的的主程序代码中加入#include "VLD.h“，并将编译好的Lib文件放入默认的库目录，然后在Visual C++用Debug模式编译运行程序，程序运行结束后便可在Visual C++的输出窗口看到内存泄露检测结果。通过宏定义控制测试行为，如报告的详略等。支持Windows X64。检测报告很直观，甚至能显示泄漏内存的内容。
    >
    > Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。
    > Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。
    >
20. C++多态如何实现？如何正确寻址到正确的虚函数？

    > 派生类是有自己的虚函数表的。
    >
21. mutex、lock_guard、unique_lock的区别？
22. RAII如何实现？
23. 智能指针的种类和特点？
24. 什么是深拷贝和浅拷贝？类中有一个指针变量，如何实现其对象深拷贝？具体的，A对象赋值给B对象，如何实现深拷贝？示例为：

    Myclass obj1 = new Myclass("hello");
    Myclass obj2(obj1);
    Myclass obj3 = new Myclass("hello wold");
    obj3 = obj1;	//重载=运算符，这里没理解清楚问题，没直接回答出来

    > 重载拷贝构造函数、重载赋值运算符
    >
25. 堆和二叉树的区别？

    > 将一堆数据看作是完全二叉树的结构存储在一维数组中，如果所有父节点都不大于它的子节点为小堆，如果所有父节点都不小于它的孩子结点为大堆。
    >
26. TCP和UDP的区别？
27. TCP三次握手？第三次的握手报文一直丢失后会怎么样？

    > 客户端等待两个报文生命周期后断开连接。服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。
    >
28. HTTP和TCP分别属于哪一层协议？
29. 网络层协议有哪些？

    > **路由协议**：**RIP、OSPF、BGP**
    >
    > * **邻居发现阶段** ：运行了路由协议后，路由器会主动把自己的网段信息发送给相邻的路由器。既可以使用广播发送路由协议消息，也可以单播将路由协议消息发送给指定的邻居路由器。
    > * **交换路由信息阶段** ：发现邻居后，每台路由器都将自己的路由信息发送给相邻的路由器，相邻路由器又发送给下一个相邻的路由器。经过一段时间后，每台路由器都会收到网络中所有的路由信息。
    > * **计算路由阶段** ：每一台路由器都会运行某种算法，计算出最终的路由表来。Dijkstra算法
    > * **维护路由阶段** ：为了感知突然发送的网络故障，比如：设备故障或线路中断等，路由协议规定相邻两台路由器之间，应该周期性发送协议报文。如果路由器在一段时间内，没收到邻居发来的协议报文，就认为邻居路由器失效。
    >
    > **IP 协议**：提供无连接的、不可靠的、尽力的数据报投递服务。**无连接**指的是发送端可以在任何时候发送数据，而接收端不会提前知道。且发送的数据报可能走不通的路径。**不可靠**指的是传输过程中发生IP数据报的丢失、重复、延迟和乱序等现象时，IP协议不会做任何检测，也不会通知接收双方。IP数据包的丢失是可以由ICMP报文告知。尽力的投递指的是，如果数据报超过数据链路层规定的最大传输单元，那么会被分组进行传送，以适合具体的传输网络。
    >
    > **ARP 协议**：地址解析协议，将IP地址转换为MAC地址。ARP请求(多播)，携带发送方的MAC地址和IP地址以及接收方的IP地址，然后进行广播；ARP响应(单播)局域网中的每一台主机都会接收并处理这个ARP请求报文，然后进行验证，判断报文目的IP是否为自己，是的话会通过单播返回响应报文，携带接收方的IP地址和MAC地址。
    > **ICMP 协议**：确认IP包是否成功到达目标地址；通知在发送过程中IP包被丢弃的原因。其会将错误信息封包，然后传回给主机。
    >
30. 网段划分？一个IP地址一个端口是什么协议？

    > IP协议
    >
31. HTTPS 如何加密？建立连接的流程是怎么样的？

    > SSL
    >
32. 阴影位置如何转换从而投影到地上的屏幕？
33. epoll 和select、poll的区别？
34. Web 服务器只是练手项目么，还是在项目中有使用？
35. epoll 的常用函数？
36. 经历那块要多了解一下，对 VR 整体的渲染要有点了解？？
37. HR面评建议AI算法优化部分有欠缺？？

## 深圳市若创科技_20240915

1. 人体姿态识别项目如何解决人物背对摄像头的问题？
2. 智能指针和移动语义在哪用过？有对比过使用前后的差别么？
3. 如何实现与相机同步？
4. 线程池如何将线程创建延迟到使用的时候？线程池线程执行的任务如果长时间占用，如何终止该任务？
   > 加入管理线程，可以延迟创建。。。？？
   >
5. 用过哪些设计模式？优缺点是什么？
   > 单例优点：避免共享资源的多重占用；只有一个对象，可以节约系统资源；提供了对唯一实例的受控访问
   > 单例缺点：没有抽象层，扩展有很大困难；职责过重，违反单一职责原则，需要解决多个不同的需求和功能；在有垃圾回收机制的语言中可能因为长时间不使用，被误认为是垃圾，被自动销毁并回收资源。
   > 适用场景：创建对象耗时过多，但又经常用到的对象；有状态的工具类对象，如文件对象；需要频繁实例化然后销毁的对象
   >
6. 小根堆定时器如何做到定时处理超时事件？
   > 每次事件循环最后会调用超时事件处理函数，处理当前事件循环持有的定时器管理器中的超时事件。
   > 实际上也可以用alarm 系统调用设置定时器，周期性的调用事件处理函数，使用方法如下
   > signal(SIGALRM，sig_handler);	//设置SIGALARM信号的信号处理函数
   > alarm(5);		//设置5秒后触发SIGALARM信号，注意重复使用的话需要在执行完信号处理函数时重新设置 alarm(5);
   >
7. cmake 和交叉编译接触过么？

## 360C++开发实习生_20240808

写三个线程严格按ABC顺序分别打印字符A、B、C，共10次。[代码在：three_thread.cpp]

webserver项目：（基本忘完了）

1. 其中的线程池如何实现？想一下线程池是怎么实现的，锁和条件变量是怎么用的，线程之间是怎么交互的，需要理解地深入一些。（只会创建线程，条件变量忘了）
2. 新连接来临时，如何唤醒工作线程？自答eventfd（存疑，需进一步看代码，描述条理需要更清晰）
3. 任务是如何分发给线程的？一个线程阻塞是否会阻塞其他线程？新的请求到来后如何分发？（自己没搞清楚新请求到来时到底是）
4. 实现线程池时是否用到条件变量？（忘了在哪用）

人体姿态识别SDK开发项目：

1. 实习具体是做什么的？目的是什么？
2. 性能调优是如何做的？（火山模型）

Facefusion脸部分析和换脸模型部署：

1. 模型部署的难点是什么？（没有标明技术上的难点，只说了模型输入输出处理难）
2. 推理加速是怎么做的？（只回答了硬件加速，可以考虑编程技巧）
3. 模型部署时是分布式的还是单机的？自答：一张图片多张脸如何处理（除了借助模型批处理，如何用多线程等编程特性进行处理和优化）。

八股：

1. C++11新特性都有哪些？自答移动语义
2. 刚提到的完美转发是如何实现的？（注意std::move和std::forward的区别，当时会达成move，可以借助一个转移函数讲解）
3. 还有什么C++11新特性？智能指针等（当时全忘了）
4. C++定义一个指针为nullptr，然后直接解引用，能编译过么？（后来测试可以通过，但运行时segment fault）
5. C++编译链接过程？静态链接和动态链接的区别？（回答不清晰）
6. Linux下I/O多路复用是什么意思？（直接全忘），了解过哪些I/O模型，select、poll和epoll有哪些区别？（全忘了）
7. 用户态和内核态的区别？（嘎嘎吹，但是没条理，理解不深）
8. 多进程、线程的底层实现（webserver代码中有相关实现）

其它：

1. 两项专利做的是什么？疲劳驾驶选择场景的耗时多少？另外一个专利是做什么的？（说自己了解不深，排名较后）都是在研究生阶段做的么？

# 未分类

1. 虚函数表存放在哪里？多态时虚函数表指针如何变化？构造函数可以是虚函数么？
   > 虚函数表存放在全局数据区，虚函数表归类所有，而非类对象。
   > 父类指针指向子类对象时，将访问的是子类对象的虚函数表。
   > 构造函数不可以是虚函数，虚函数表指针存放在对象的头部，构造函数在对象构造完成前被调用，由于此时的对象还未完成构造，虚表指针也就并未确定，因此无法通过续表指针调用构造函数。
   > [C++虚函数表原理浅析-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1816474)
   >
2. 模板类的全特化、偏特化、主版本模板类，常规函数、具体化模板函数、常规模板函数
   > 函数重载决议无视模板特化，重载决议后再判断模板特化。
   > [C++模板全特化（具体化）与偏特化（部分具体化）详解_c++ 函数 部分具体化-CSDN博客]()[
   > ](https://blog.csdn.net/greywolf0824/article/details/106856397)
   >
